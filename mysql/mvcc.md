# MVCC(多版本并发控制)

mysql中提供的锁，当获取排他锁的时候，其他一切操作都会被阻塞，这样无法满足高并发的场景。所以提供了MVCC。

## 概念

并发访问(读或写)数据库时，对正在事务内处理的数据做多版本的管理。以达到用来避免写操作的堵塞，从而引发读操作的并发问题。

## 原理

* 当为数据加排他锁时，即写任务时，先将要操作数据克隆一份，以版本号区分。
* 写任务直接操作新克隆的数据，直至提交。
* 并发读任务可以直接读之前版本数据，不会因为锁阻塞。

## MVCC应用

InnoDB的内核，会对所有row数据增加三个内部属性：

* **DB_TRX_ID**，6字节，记录每一行最近一次修改它的事务ID；
* **DB_ROLL_PTR**，7字节，记录指向回滚段undo日志的指针；
* **DB_ROW_ID**，6字节，单调递增的行ID；

而其中**DB_TRX_ID**与**DB_ROLL_PTR**就是MVCC的多版本控制版本号。

* 当执行Insert插入操作时，会在**DB_TRX_ID**中记录当前事务ID；
* 当执行delete删除操作时，会在**DB_ROLL_PTR**中记录当前事务ID；
* 当执行update修改操作时，会先在copy出一条记录，在**DB_TRX_ID**中记录当前事务ID，并在原记录**DB_ROLL_PTR**中记录当前事务ID。
* 当执行select查询操作时，将会按照规则查询
  * 查询数据行版本**DB_TRX_ID**早于当前事务版本的数据行
    * 这样确保读取的数据是在事务开始前就已经存在的，或者是当前事务自身插入或修改过的。
  * 查找删除版本号**DB_ROLL_PTR**要么为null，要么大于当前事务版本号的记录
    * 确保取出来的行记录在事务开始之前没有被删除

但是只是这样的操作会出现问题，当一个事务先做修改后未提交，另一个事务此时再查询时将会读出上一个事务未提交处理的数据。

基于这样的问题，通过Undo日志来解决。首先要了解下redo日志，undo日志，回滚段（rollback segment）。 

## redo日志

数据库事务提交后，必须将更新后的数据刷到磁盘上，以保证ACID特性。磁盘**随机写**性能较低，如果每次都刷盘，会极大影响数据库的吞吐量。

优化方式是，将修改行为先写到redo日志里（此时变成了**顺序写**），再定期将数据刷到磁盘上，这样能极大提高性能。

**画外音：这里的架构设计方法是，随机写优化为顺序写，思路更重要。**

假如某一时刻，数据库崩溃，还没来得及刷盘的数据，在数据库重启后，会重做redo日志里的内容，以保证已提交事务对数据产生的影响都刷到磁盘上。

**一句话**，redo日志用于保障，已提交事务的ACID特性。

## **undo**日志

数据库事务未提交时，会将事务修改数据的镜像（即修改前的旧版本）存放到undo日志里，当事务回滚时，或者数据库奔溃时，可以利用undo日志，即旧版本数据，撤销未提交事务对数据库产生的影响。

* UndoLog 是为了实现事务的原子性而出现的产物
* UndoLog 在Mysql innodb 存储引擎中用来实现多版本并发控制

***画外音：更细节的，***

**对于insert操作**，undo日志记录新数据的PK(ROW_ID)，回滚时直接删除；***

***对于*delete/update操作**，undo日志记录旧数据row，回滚时直接恢复；***

***他们分别存放在不同的buffer里。***

**一句话**，undo日志用于保障，未提交事务不会对数据库的ACID特性产生影响。

## 什么是回滚段？

存储undo日志的地方，是回滚段。



## InnoDB为何能够做到这么高的并发？ 

回滚段里的数据，其实是历史数据的快照（snapshot），这些数据是不会被修改，select可以肆无忌惮的并发读取他们。 

* 快照读（**一致性不加锁的读** ）
  * SQL 读取的 数据 是快照版本，也就是历史版本 ， 普通的SELECT
  * innodb 快照读，数据的读取将由 cache( 原本数据) + undo( 事务修改过的数据) 
* 当前读
  * SQL 读取的 数据 是最新版本 。通过锁机制来保证读取的数据无法通过其他事务进行修改
  * UPDATE 、DELETE 、INSERT 、SELECT … LOCK IN SHARE MODE 、SELECT … FOR UPDATE 都是
    当前读

