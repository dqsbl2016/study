# 基础

## 线程安全

多线程操作共享数据时产生的问题。 读写的数据实时性。

## 层次

* 线程安全  线程竞争产生的问题 免于竞争产生的问题
* 条件安全    不同的线程可以同时访问不同的对象，并且对共享数据的访问不受竞争条件的限制。
* 非线程安全  数据结构不应该同时被多线程访问

## 实现方式

* 重进入    当一个线程进入临界区时，只要获取到锁后可重复性的进入。
  * ReentrantLock  可重入锁
* 线程本地存储
  * ThreadLocal  
* 不可变对象   
  * java 9以上  Set.class
  * final （但是反射时可改变这个修饰的值）
* 互斥
  * 锁    会造成死锁  资源饥饿等情况
* 原子性
  * 
* 可见性
  * Happen - Before   保证的是可见性
* 同步
  * Synchronization   同步进程或 同步数据   java中的不一定是互斥的
  * 死锁 饥饿  优先级倒置  繁忙等待(活锁)



## 同步实现

* 信号量   
  * Semaphore.java ??
* 内存屏障
  * CyclicBarrier.java ??
* 互斥
  * 可能包括一个点 或 一块代码（临界区）
* 条件变量
* 自旋锁
  * Thread   java9中有自旋锁实现  静态方法OnSpinWait() 
* 读-写锁
  * ReentrantReadWriteLock  读写锁（共享/独占模式）



## 名词

* 临界区
* 锁 （互斥）  互斥的结果就是 串行的执行

## 同步原语 Synchronization   

* 锁类型
  * 对象锁 
    *   synchronized 加到 非static 方法 
    * 直接锁一个对象  object等类型
    * 锁this
    * synchronized修饰代码块 
  * 类锁  
    * synchronized 加到 static 方法 
    * 直接锁当前class本身  ***.class /

> Monitor - > Object   Monitor只会读Object对象

* 重进入锁  防止死锁  计算进入次数
* 方法Flags： 方法签名  类文件结构中有   是不是public  是不是静态  是不是有synchronized 修饰 ACC_synchronized 
* 字节码 
  * monitorenter   
  * monitorexit
* 锁实现
  * Thin Lock
  * Inflated
  * HeavyWeight

