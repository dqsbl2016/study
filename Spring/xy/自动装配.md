# Web.xml自动装配替换

## ServletContainerInitializer 

首先需要了解一个接口`ServletContainerInitializer `。

```java
public interface ServletContainerInitializer {
    public void onStartup(Set<Class<?>> c, ServletContext ctx)
        throws ServletException; 
}
```

这个是Servlet 3.0中增加的一个接口。它的目的就是为了实现不通过Web.xml启动javaEE项目。当web容器启动时就会运行这个初始化容器做一些初始化工作。而使用的方式是通过SPI机制。在对应META-INF/services目录下创建名为javax.servlet.ServletContainerInitializer的文件，文件内容指定具体的ServletContainerInitializer实现类 。

这里以Spring的实现为例子，在Spring中实现了一个类`SpringServletContainerInitializer`。可以在对应元数据路径下查看到对应的内容`org.springframework.web.SpringServletContainerInitializer`。

而ServletContainerInitializer 一般会搭配@HandlesTypes注解，通过这个注解将一些需要的类注入到ServletContainerInitializer 的onStartup方法中作为参数传入。这里依然以Spring为例子。

```java
@HandlesTypes(WebApplicationInitializer.class)
public class SpringServletContainerInitializer implements ServletContainerInitializer {
	@Override
	public void onStartup(@Nullable Set<Class<?>> webAppInitializerClasses, ServletContext servletContext)
			throws ServletException {

		List<WebApplicationInitializer> initializers = new LinkedList<>();

		if (webAppInitializerClasses != null) {
			for (Class<?> waiClass : webAppInitializerClasses) {
				// Be defensive: Some servlet containers provide us with invalid classes,
				// no matter what @HandlesTypes says...
				if (!waiClass.isInterface() && !Modifier.isAbstract(waiClass.getModifiers()) &&
						WebApplicationInitializer.class.isAssignableFrom(waiClass)) {
					try {
						initializers.add((WebApplicationInitializer)
								ReflectionUtils.accessibleConstructor(waiClass).newInstance());
					}
					catch (Throwable ex) {
						throw new ServletException("Failed to instantiate WebApplicationInitializer class", ex);
					}
				}
			}
		}

		if (initializers.isEmpty()) {
			servletContext.log("No Spring WebApplicationInitializer types detected on classpath");
			return;
		}

		servletContext.log(initializers.size() + " Spring WebApplicationInitializers detected on classpath");
		AnnotationAwareOrderComparator.sort(initializers);
		for (WebApplicationInitializer initializer : initializers) {
			initializer.onStartup(servletContext);
		}
	}
```

这其中就会将WebApplicationInitializer.class类型的对象传入`onStartup`方法，进行一些处理后，遍历直接具体的`onStartup`启动方法。

## WebApplicationInitializer

`WebApplicationInitializer`支持在servlet 3.0 以上的环境里通过编程的方式来配置ServletContext，这种方式可以替换web.xml，也可以与web.xml共存。

* `WebApplicationInitializer`
  * `AbstractContextLoaderInitializer`
    * `AbstractDispatcherServletInitializer`
      * `AbstractAnnotationConfigDispatcherServletInitializer`
  * `AbstractReactiveWebInitializer`

所以使用中可以继承`AbstractAnnotationConfigDispatcherServletInitializer`的方式，进行自动配置装配。