# GC 垃圾回收

## 如何知道对象已死（需要回收）

### 引用计数算法

为对象增加一个引用计数器，每当有地方引用次数加1，当引用失效后次数减1.

* 问题：当出现互相引用时，永远无法回收

### 可达性分析算法（当前使用）

通过一系列称为“GC Roots”的对象做为起点，从这些节点向下搜索，所走过的路径成为引用链，当一个对象没有任何引用链相连，则证明这个对象时无用的，需要回收。

哪些会做为GC Roots对象

* 虚拟机栈中（栈帧中局部变量表中）引用的对象
* 方法区中类静态属性引用的对象
* 方法区中常量引用的对象
* 本地方法栈中（Native方法）引用的对象

## 引用

引用分为多种概念

### 强引用

指在程序代码中普遍存在的，类似Object obj  = new Object();这类引用，只要引用关系还存在，永远不会被回收

### 软引用

非必须引用，内存溢出之前会进行回收，

Object obj = new Object(); 

SoftReference<Object> sf = new SoftReference<Object>(obj);

 obj = null; 

sf.get();//有时候会返回null 

这时候sf是对obj的一个软引用，通过sf.get()方法可以取到这个对象，当然，当这个对象被标记为需要回收的对象时，则返回null； 软引用主要用户实现类似缓存的功能，在内存足够的情况下直接通过软引用取值，无需从繁忙的真实来源查询数据，提升速度；当内存不足时，自动删除这部分缓存数据，从真正的来源查询这些数据。 

### 弱引用

第二次垃圾回收时回收，可以通过如下代码实现 

Object obj = new Object(); 

WeakReference<Object> wf = new WeakReference<Object>(obj); 

obj = null; 

wf.get();//有时候会返回null 

wf.isEnQueued();//返回是否被垃圾回收器标记为即将回收的垃圾

 弱引用是在第二次垃圾回收时回收，短时间内通过弱引用取对应的数据，可以取到，当执行过第二次垃圾回收时，将返回null。 弱引用主要用于监控对象是否已经被垃圾回收器标记为即将回收的垃圾，可以通过弱引用的isEnQueued方法返回对象是否被垃圾回收器标记。 

### 虚引用

垃圾回收时回收，无法通过引用取到对象值，可以通过如下代码实现 

Object obj = new Object(); 

PhantomReference<Object> pf = new PhantomReference<Object>(obj); 

obj=null;

 pf.get();//永远返回null

 pf.isEnQueued();//返回是否从内存中已经删除 

虚引用是每次垃圾回收的时候都会被回收，通过虚引用的get方法永远获取到的数据为null，因此也被成为幽灵引用。 虚引用主要用于检测对象是否已经从内存中删除。 

## 垃圾回收算法

### 标记-清除算法

分标记和清楚两个阶段，首先标记出要清除的对象，在标记完成后统一回收清除对象。

> 清除后会产生大量不连续的内存碎片，碎片太多会导致当需要分配较大对象时，无法找到足够的连续内存空间而再触发回收

### 复制算法

将内存分为大小相等的两块，每次只使用其中一块，当一块内存用完后，触发回收，然后将还存活的对象复制到另一块内存中，再将此内存空间内容全部清理掉。

> 代价时使用内存变成了原来的一半，目前新生代就是此种算法，每次只使用伊甸园与其中一块survivor空间，回收时将全部存活对象复制到另一块survivor空间。

### 标记-整理算法

标记过程与标记-清除算法一样，然后让存活对象都向一端移动，然后直接清理掉端边界以外的内存。

### 分代收集算法

目前虚拟机使用算法，即将内存分为新生代与老年代，根据不同区域情况，选择不同的算法。例如新生代每次收集都会有大量对象被回收，所以采用复制算法。老年代每次回收对象不多，使用标记-清除算法或者标记-整理算法。

## hotspot的算法

### 枚举根节点（定位GC Roots）

首先检查寻找可以做为GC Roots的节点的引用会消耗很多时间（因为要从检查所有可做为GC Roots节点的引用，栈，静态变量，变量等的引用），而这项分析工作必须再一个能确保一致性的快照中进行。不能出现在分析过程中对象引用关系还在不断的变化。这个也是导致垃圾回收时必须停顿所有java线程的一个重要原因。

> stop the whorld 原因

hotspot会使用一组成为OopMap的数据结构来记录那些地方存放着对象引用（类加载完成，编译的时候就会记录哪些位置是引用）



## 垃圾回收器

### serial收集器（新生代）

新生代单线程收集器，回收时会stop the world，采用复制算法

### parnew收集器 （新生代）

新生代多线程收集器，回收时会stop the world ，采用复制算法

### parallel scavenge收集器(新生代)

新生代多线程收集器，回收时不会stop the world ,同样采用复制算法，目的时达到一个可控制的吞吐量，吞吐量 = 运行用户代码时间/垃圾回收时间， 即虚拟机运行100分钟，垃圾回收使用了1分钟，则吞吐量就是99%。 

此收集器无法与CMS配合，所以新生代选此收集器后老年代无法选择CMS收集器。

### serial old 收集器（老年代）

老年代单线程收集器，回收时会stop the world，采用标记-整理算法。

### parallel old 收集器(老年代)

老年代多线程收集器，回收时不会stop the world，采用标记-整理算法。主要关注吞吐量,通过吞吐量的设置控制停顿时间,适应不同的场景 

### CMS 收集器（老年代）

是一个以获取最短回收停顿时间为目标的收集器。基于标记-清除算法实现的。整个过程分为4步：

* 初始标记
  * stop the world 
  * 单线程处理
  * 标记一下GC Roots能直接关联的对象，速度很快
* 并发标记
  * 多线程处理
  * 按GC Roots的直接关联对象 查引用链，标记存活对象
* 重新标记
  * stop the world
  * 多线程处理
  * 修正并发标记期间，用户程序继续运行导致标记产生变动的那一部分标记对象
  * 停顿时间会比第一阶段要长一些
* 并发清除
  * 多线程处理
  * 按照标记内容，开始清理未标记对象

>缺点： 因为使用的是标记-清除算法，所以会出现大量空间碎片，CMS提供一个配置（默认开启），会再回收之后开启内存碎片的合并整理过程。	另外还提供一个参数，可以设置当执行多少次不压缩的Full GC后，再跟着做一次压缩的。

### G1 收集器

现最流行的是G1(Garbage First)收集器，也是当今收集器技术发展的最前沿成果之一，现重点学习一下。

**1.优点**

- 并行与并发;
- 分代收集；虽然G1可以不需要其他收集器配合而独立管理整个GC堆,但是它能够采用不同的收集算法去处理新创建的对象和已经存活一段时间，熬过多次GC的对象。
- 空间整合;G1整体是基于标记-整理算法。所以运行期间不会产生内存碎片，收集后能提供规整的可用内存。在分配打对象时不会因为无法找到连续内存而触发下一次GC。
- 可预测的停顿;G1除了追求低停顿以外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不超过N毫秒。

**2.特点**

- 对堆的划分；G1之前的收集器对内存的收集都是新生代或者老年代，而G1不在这样。使用G1收集器时，Java堆的内存布局就和其他收集器有很大区别，他将整个堆划分成多个大小想等的区域（Region）.虽然还有概念上的新生代和年老代，但他们之间已经不在物理隔离了，他们都是一部分Region(不需要连续的)的集合。
- 回收等级;G1能实现可预测的停顿是因为它可以避免对堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾的价值（回收的内存大小和时间的比值）大小，在后台维护一个优先列表，每次优先回收价值最大的Region，这也是可预测停顿的实现的原理。

 

**3.需要思考的问题**

　G1把内存化整为零，将整个堆划分为多个Region。那么垃圾收集真的就是以Region为单位进行的吗?听起来顺理成章，仔细想想其实不是，Region不可能是孤立的。一个对象分配在某个Region中，但它并不是只能被本Region中的其他对象引用，而是可以为整个堆中的任意其他对象引用。那么在利用可达性分析判断对象是否存活时，岂不是要扫描整个Java堆才能保证准确性？此类问题在其他收集器中也会出现，新生代年老代同样面临此类问题。

　　此类问题的JVM采用Remembered Set来避免全堆扫描。（包括新生代年老代的解决思路）。

 

**4.运作步骤**

- 初始标记
  - stop the world 
  - 单线程处理
  - 标记一下GC Roots能直接关联的对象，速度很快
  - 修改TAMS的值，让下一阶段运行时，能在正确可用的Region中创建新对象。
- 并发标记
  - 多线程处理
  - 按GC Roots的直接关联对象 查引用链，标记存活对象
- 最终标记
  - stop the world
  - 多线程处理
  - 修正并发标记期间，用户程序继续运行导致标记产生变动的那一部分标记对象，虚拟机会将这段时间对象变化记录在线程Remembered Set logs里面，这个阶段会将logs的数据合并到Remembered Set中
- 筛选回收
  - 首先对各个Regin的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划。
  - 多线程处理

## OopMap

当垃圾回收时，收集线程会对栈上的内存进行扫描，看看那些位置上存储了Reference类型。如果发现了某个位置上存储的是Reference类型，就意味着这个引用所指向的对象在这一次垃圾回收过程中不能够回收。

​        栈上的本地变量表里面只有一部分数据是Reference类型的，为了避免每次都扫描整个栈，所以采用空间换时间的策略。在某个时候(安全点)把栈上代表引用的位置记录下来，GC时直接读取，避免了全部扫描。 HotSpot虚拟机采用了一种叫做OopMap的数据结构来记录这些引用（OopMap也帮助HotSpot实现了准确式GC），OopMap记录了栈上本地变量到堆上对象的引用关系，这些引用指向的对象不能够回收，并且可以作为根节点来进行可达性分析，查找出不能够回收的对象。

一个线程意味着一个栈，一个栈由多个栈帧组成，一个栈帧对应着一个方法，一个方法里面可能有多个安全点。 gc 发生时，程序首先运行到最近的一个安全点停下来，然后更新自己的 OopMap ，记下栈上哪些位置代表着引用。枚举根节点时，递归遍历每个栈帧的 OopMap ，通过栈中记录的被引用对象的[内存地址](https://www.baidu.com/s?wd=%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd)，即可找到这些对象（GC Roots）。 所以说一个方法可能有多个OopMap，每一个的记录的也只仅限于自己的那一段代码。

 

## RememberedSet 

新生代 GC（发生得非常频繁）。一般来说， GC过程是这样的：首先枚举根节点。根节点有可能在新生代中，也有可能在老年代中。这里由于我们只想收集新生代（换句话说，不想收集老年代），所以没有必要对位于老年代的 GC Roots 做全面的可达性分析。但问题是，确实可能存在位于老年代的某个 GC Root，它引用了新生代的某个对象，这个对象你是不能清除的。那怎么办呢？  

 事实上，对于位于不同年代对象之间的引用关系，虚拟机会在程序运行过程中给记录下来。对应上面所举的例子，“老年代对象引用新生代对象”这种关系，会在引用关系发生时，在新生代边上专门开辟一块空间记录下来，这就是RememberedSet，RememberedSet记录的是新生代的对象被老年代引用的关系。所以“新生代的 GC Roots ” + “ RememberedSet 存储的内容”，才是新生代收集时真正的 GC Roots 。然后就可以以此为据，在新生代上做可达性分析，进行垃圾回收。

   

​       G1 收集器使用的是[化整为零](https://www.baidu.com/s?wd=%E5%8C%96%E6%95%B4%E4%B8%BA%E9%9B%B6&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd)的思想，把一块大的内存划分成很多个域（ Region ）。但问题是，难免有一个 Region 中的对象引用另一个 Region 中对象的情况。为了达到可以以 Region 为单位进行垃圾回收的目的， G1 收集器也使用了 RememberedSet 这种技术。G1中每个Region都有一个与之对应的RememberedSet ，在各个 Region 上记录自家的对象被外面对象引用的情况。当进行内存回收时，在GC根节点的枚举范围中加入RememberedSet 即可保证不对全堆扫描也不会有遗漏。

> https://blog.csdn.net/ifleetingtime/article/details/78934379

 

## 日志分析

