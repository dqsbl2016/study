---
typora-root-url: img
---

# 运行时数据区

Java虚拟机在运行Java程序时会将它管理的内存划分为若干个不同的数据区域。

## 程序计数器（线程私有）

* 线程私有，每个线程会分配一个。
* 记录当前线程所执行的字节码的行号指示器，记录当前线程执行的位置。
  * 为了当线程挂起再恢复后可以恢复到正确的执行位置。
  * 如果线程执行的是Java方法，计数器记录的是当前线程执行虚拟机字节码指令的地址
  * 如果线程执行的是Native方法，这个计数器的值为空。
* 唯一一个不会出现内存溢出错误（OutOfMemoryError）的区域。

## java 虚拟机栈（线程私有）

Java虚拟机栈是描述Java方法执行的内存模型。虚拟机中只存在一个Java虚拟机栈，但是每个方法执行的同时都会创建一个栈帧区域，同时进行入栈操作，而当方法执行完后会做出栈操作。每个栈帧包括下面区域：

### 局部变量表

存放了编译期方法中所有的变量，其中包括

* 各种基本数据类型（boolean,byte,char,short,int,float,long,double）
* 对象引用（reference类型，可能是指向对象的指针，也可能指向一个代表对象的句柄或其他与对象相关的位置）
* returnAddress类型（指向一条指令字节码的地址）

> 其中每一个空间的长度为32，所以long和double类型会占据2个局部变量空间。
>
> 第0个索引的值默认是this

### 操作数栈

也叫操作栈，它是一个后入先出的栈，记录编译后的执行指令集。java虚拟机解释执行引擎称为“基于栈的执行引擎”，其中所指的栈就是操作数栈。

### 动态链接

在class文件中，描述一个方法调用其他方法或访问其他成员变量是通过符号引用来表示的，而动态链接的作用就是将这些符号引用所表示的方法转换为实际方法的引用。

**这些符号引用一部分会在类加载阶段或者第一次使用的时候就转化为直接引用，这种转化称为静态解析。另外一部分将在每一次运行期间转化为直接引用，这部分称为动态连接。（静态分派，动态分派）** 

```java
例如：
public class Test（）{
	private Service service；
	
    public void do(){
       service.do();
    }
}
这里service的具体引用，将会记录在动态链接，会指向堆中的service实际使用对象。
```

### 方法返回地址

方法结束后的字节码指令地址 。

* 正常退出，执行引擎遇到任意一个方法返回的字节码指令，返回上层调用者。
* 异常退出，异常没有在本方法处理，会导致方法退出。返回的地址要通过异常处理器表来确定。



>  虚拟机栈中会出现两种错误：
>
> * StackOverflowError: 如果线程请求的栈深度大于虚拟机所允许的深度。
> * OutOfMemoryError: 如果虚拟机栈可以动态扩展，当扩展时无法申请到足够的内存是，抛出OutOfMemoryError(当前大部分虚拟机都支持动态扩展，只不过虚拟机规范中也允许固定大小的虚拟机栈

## 本地方法虚拟机栈（线程私有）

本地方法栈与java虚拟栈实现的功能类似，只不过本地方法栈是本地方法的内存模型，也会创建栈针，区域信息与java虚拟机栈一样。 

## 堆（公有区域）

java堆是Java虚拟机所管理的内存中最大的一块。此区域唯一的目的就是存放对象实例。

另外数组会直接放入堆中。

主要分为两个区域：

* 新生代
  * eden空间：占新生代的80%
  * From Survivor空间：占10%
  * To Survivor空间：占10%

  其中From Survivor 与 To Survivor空间是一定相等的。

* 老年代

  默认老年代的空间是新生代的2倍

### 一些规则

* 新生代采用复制算法，所以只会使用eden区及一个survivor空间（换个说法只会使用90%的内存），当GC后会将存活对象复制到另一个survivor中。
* 新生代空间为什么这样分配，因为新生代大部分对象生命周期很短，一次GC后大部分都会被回收。
* 当有大对象时（新生代无法容纳），将会开启担保机制，由老年代进行空间担保，如果新生代GC还是放不下后，会将大对象存入老年代。
* 可以设置参数，让大于这个大小的对象（大对象）直接回进入到老年代。
* 

>  此区域会出现一种错误：
>
> * OutOfMemoryError: 当堆中无空间后将报内存溢出错误

## 方法区（公有区域）

同堆一样是各个线程的共享区域，它用于存储已被虚拟机加载的类信息/常量/静态变量/即时编译器编译后的代码（JIT）等数据。更细的说法是方法区中存放着

* 全局字符串池

* Class文件信息（类的版本/字段/方法/接口和class常量池）。
  * class常量池里存储着字面量和符号引用。
* 运行时常量池

### 全局字符串池

在HotSpot VM里实现的是一个StringTable类，它是一个哈希表，里面存的是驻留字符串(也就是我们常说的用双引号括起来的)的地址引用，如果是通过new String（‘abc’）方式创建的，里面存的是在堆中这个对象的引用地址。 所以String s1 = “abc”;  String s2 = new String("abc");   s1 == s2  为false。

### Class文件信息又包括哪些？

![class2](/class2.png)

  可以看到在方法区里的class文件信息包括：魔数，版本号，常量池，类，父类和接口数组，字段，方法等信息，其实类里面又包括字段和方法的信息。 

#### Class常量池中包括内容

![class3](/class3.png)

这其中文本字符串的值会指向全局字符串池中的值。

### 运行时常量池

jvm在执行某个类的时候，必须经过**加载、连接、初始化**，而连接又包括验证、准备、解析三个阶段。而当类加载到内存中后，jvm就会将class常量池中的内容存放到运行时常量池中，由此可知，运行时常量池也是每个类都有一个。 而经过解析（resolve）之后 ，会将符号引用替换为直接引用，解析的过程会去查询全局字符串池， 以保证运行时常量池所引用的字符串与全局字符串池中所引用的是一致的。 

```java
例子：
String str1 = "abc"; 
String str2 = new String("def"); 
String str3 = "abc"; 
String str4 = str2.intern();
String str5 = "def"; 
System.out.println(str1 == str3);//true 
System.out.println(str2 == str4);//false 
System.out.println(str4 == str5);//true  

```

```java
上面程序的首先经过编译之后，在该类的class常量池中存放一些符号引用，然后类加载之后，将class常量池中存放的符号引用转存到运行时常量池中，然后经过验证，准备阶段之后，在堆中生成驻留字符串的实例对象（也就是上例中str1所指向的”abc”实例对象），然后将这个对象的引用存到全局String Pool中，也就是StringTable中，最后在解析阶段，要把运行时常量池中的符号引用替换成直接引用，那么就直接查询StringTable，保证StringTable里的引用值与运行时常量池中的引用值一致，大概整个过程就是这样了。
```

```java
具体流程：
首先会在也就是StringTable中放入"abc",返回abc的指向给str1
堆中创建String（"def"）对象，StringTable放入“def”,并且记录的是def本地的地址，然后返回堆对象地址给str2
判断StringTable中已存在“abc”,返回abc的指向给str1
判断str2在StringTable已经存在，返回其中的指向（def本地的地址）给str4
判断StringTable中已经存在“def”，返回其中的指向（def本地的地址）给str5

所以 str1 == str3  true
str2 == str4      false 
str4 == str5      true
```



* 当在堆中的数据经过指定次回收后依然没有被回收的情况下，会将数据放入方法区中。

> 此区域会出现一种错误：
>
> * OutOfMemoryError: 当堆中无空间后将报内存溢出错误

## String对象问题总结

- 直接使用双引号创建字符串

```java
判断这个常量是否存在于常量池，
  如果存在，
      则返回这个常量池中常量的地址，
  如果不存在，
    在常量池中创建该常量，并返回常量地址
```

- new String创建字符串

```java
首先在堆上创建对象(无论堆上是否存在相同字面量的对象)
 然后判断常量池上是否存在字符串的常量，
  如果不存在
   在常量池上创建该常量
  如果存在
   不做任何操作
 最后会返回堆中对象地址
```

- 双引号相加

```java
判断这两个常量、相加后的常量在常量池上是否存在
  如果不存在
   则在常量池上创建相应的常量（返回相加后常量地址）
  如果存在
    则直接返回常量池常量地址（返回相加后的常量地址）
```

- 两个new String相加

```java
首先会在堆中创建这两个对象以及相加后的对象
 然后判断常量池中是否存在这两个对象的字面量常量
  如果存在
   不做任何操作
  如果不存在
   则在常量池上创建对应常量，创建相加后常量
 返回相加后的堆对象地址
```

- 双引号字符串与new String字符串

```java
首先会在堆中创建在两个对象，一个是new String的对象，一个是相加后的对象
 然后判断双引号常量与new String的字面量在常量池是否存在
  如果存在
   不做操作
  如果不存在
   则在常量池上创建对象的常量
返回相加后的堆对象地址
```

- String.intern()

```java
判断这个常量是否存在于常量池。
  如果存在
     直接返回常量池常量地址
  如果不存在，
   常量池中创建常量（记录常量地址）,并且返回的是当前对象堆的引用
```

> 资料 ：
>
> https://www.cnblogs.com/guozhenqiang/p/5633269.html



## 直接内存

直接内存并不是java虚拟机运行时数据区的一部分，在JDK1.4之后新加入了NIO类，它可以使用Native函数库直接分配堆外内存。



> 此区域会出现一种错误：
>
> - OutOfMemoryError: 当堆中无空间后将报内存溢出错误



## jdk 1.6 1.7  1.8 运行时数据区的变化

* 1.6  无变化
* 1.7  将运行时常量池从方法区中移除，放到了堆中
* 1.8 取消了方法区，增加了元空间，将运行时常量池放入了元空间

## 元空间

移除永久代的工作从JDK1.7就开始了。JDK1.7中，存储在永久代的部分数据就已经转移到了Java Heap或者是 Native Heap。但永久代仍存在于JDK1.7中，并没完全移除，譬如符号引用(Symbols)转移到了native heap；字面量(interned strings)转移到了java heap；类的静态变量(class statics)转移到了java heap。

　元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制 。

## 逃逸分析与栈上分配

### 逃逸分析

逃逸分析的基本行为就是分析对象动态作用域。当一个对象在方法中被定义后，而被外部方法所引用。

* **方法逃逸**  这个方法中又调用其它方法，而这个对象又被当作调用参数传递过去。

  * ```java
    例如：
    public void load(){
    	User user = new User();
    	getObject(user);
    }
    
    private String getObject(User user){
    		return user.getName();
    }
    
    ```

* **线程逃逸** 被外部线程访问到，例如赋值给类变量或在其他线程中访问的实例变量。

  * ```java
    例如：
    public class Test{
    	private User user;
    	public void load(){
            user = new User();
    	}
    }
    ```

### 优化

如果证明一个对象不会造成逃逸，则可能进行一些优化。

* **栈上分配（hotspot还未进行）**   java虚拟机中，在java堆中分配创建对象空间。而如果确认这个对象不会造成逃逸，那么直接在栈上为对象分配空间更好，因为会随着出栈直接将对象空间也进行回收，减少GC压力。

* **同步消除**  如果确认这对象不会造成逃逸，则表示这个对象也不会被其他线程访问，这样对这个对象的读写也不会出现竞争，从而避免同步问题。

  