# 运行时数据区

Java虚拟机在运行Java程序时会将它管理的内存划分为若干个不同的数据区域。

## 程序计数器（线程私有）

* 线程私有，每个线程会分配一个。
* 记录当前线程所执行的字节码的行号指示器，记录当前线程执行的位置。
  * 为了当线程挂起再恢复后可以恢复到正确的执行位置。
  * 如果线程执行的是Java方法，计数器记录的是当前线程执行虚拟机字节码指令的地址
  * 如果线程执行的是Native方法，这个计数器的值为空。
* 唯一一个不会出现内存溢出错误（OutOfMemoryError）的区域。

## java 虚拟机栈（线程私有）

Java虚拟机栈是描述Java方法执行的内存模型。虚拟机中只存在一个Java虚拟机栈，但是每个方法执行的同时都会创建一个栈帧区域，同时进行入栈操作，而当方法执行完后会做出栈操作。每个栈帧包括下面区域：

### 局部变量表

存放了编译期方法中所有的变量，其中包括

* 各种基本数据类型（boolean,byte,char,short,int,float,long,double）
* 对象引用（reference类型，可能是指向对象的指针，也可能指向一个代表对象的句柄或其他与对象相关的位置）
* returnAddress类型（指向一条指令字节码的地址）

> 其中每一个空间的长度为32，所以long和double类型会占据2个局部变量空间。

### 操作数栈

记录编译后的指令集。

### 动态链接

在class文件中，描述一个方法调用其他方法或访问其他成员变量是通过符号引用来表示的，而动态链接的作用就是将这些符号引用所表示的方法转换为实际方法的引用。

**这些符号引用一部分会在类加载阶段或者第一次使用的时候就转化为直接引用，这种转化称为静态解析。另外一部分将在每一次运行期间转化为直接引用，这部分称为动态连接。（静态分派，动态分派）** 

### 方法返回地址

方法结束后的字节码指令地址 

>  此区域会出现两种错误：
>
> * StackOverflowError: 如果线程请求的栈深度大于虚拟机所允许的深度。
> * OutOfMemoryError: 如果虚拟机栈可以动态扩展，当扩展时无法申请到足够的内存是，抛出OutOfMemoryError(当前大部分虚拟机都支持动态扩展，只不过虚拟机规范中也允许固定大小的虚拟机栈

## 本地方法虚拟机栈（线程私有）

本地方法栈与java虚拟栈实现的功能类似，只不过本地方法栈是本地方法的内存模型，也会创建栈针，区域信息与java虚拟机栈一样。 

## 堆（公有区域）

java堆是Java虚拟机所管理的内存中最大的一块。此区域唯一的目的就是存放对象实例。

另外数组会直接放入堆中。

主要分为两个区域：

* 新生代
  * eden空间：占新生代的80%
  * From Survivor空间：占10%
  * To Survivor空间：占10%

  其中From Survivor 与 To Survivor空间是一定相等的。

* 老年代

>  此区域会出现一种错误：
>
> * OutOfMemoryError: 当堆中无空间后将报内存溢出错误

## 方法区（公有区域）

同堆一样是各个线程的共享区域，它用于存储已被虚拟机加载的类信息/常量/静态变量/即时编译器编译后的代码等数据。

* 当在堆中的数据经过指定次回收后依然没有被回收的情况下，会将数据放入方法区中。



> 此区域会出现一种错误：
>
> * OutOfMemoryError: 当堆中无空间后将报内存溢出错误

## 运行时常量池

运行时常量池时方法区的一部分，



> 此区域会出现一种错误：
>
> - OutOfMemoryError: 当堆中无空间后将报内存溢出错误

## 直接内存

直接内存并不是java虚拟机运行时数据区的一部分，在JDK1.4之后新加入了NIO类，它可以使用Native函数库直接分配堆外内存。





> 此区域会出现一种错误：
>
> - OutOfMemoryError: 当堆中无空间后将报内存溢出错误



## jdk 1.6 1.7  1.8 运行时数据区的变化

* 1.6  无变化
* 1.7  将运行时常量池从方法区中移除，放到了堆中
* 1.8 取消了方法区，增加了元空间，将运行时常量池放入了元空间

## 元空间

移除永久代的工作从JDK1.7就开始了。JDK1.7中，存储在永久代的部分数据就已经转移到了Java Heap或者是 Native Heap。但永久代仍存在于JDK1.7中，并没完全移除，譬如符号引用(Symbols)转移到了native heap；字面量(interned strings)转移到了java heap；类的静态变量(class statics)转移到了java heap。

　元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制 。